package algorithm;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

public class Main_2580 {
	
	static final int SDQ_Size = 9;
	static int[][] arr;
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		arr = new int[SDQ_Size][SDQ_Size];
		Queue<Point_2580> points = new LinkedList<Point_2580>();
		
		for (int i = 0; i < SDQ_Size; i++) {
			String[] sdqInfo = br.readLine().split(" ");
			for (int j = 0; j < SDQ_Size; j++) {
				int val =  Integer.parseInt(sdqInfo[j]);
				arr[i][j] = val;
				if(val == 0) {
					points.add(new Point_2580(i, j));
				}
			}
		}
		goGame(points);
		
	}
	private static void goGame(Queue<Point_2580> points) {
		for (int i = 1; i <= 9; i++) {
			while (!points.isEmpty()) {
				Point_2580 point = points.poll();
				if(checkOne(i, point, true) && checkOne(i, point, false) && checkTwo(i, point)) {
					//가로, 세로, 정사각형 조건을 모두 만족한다면?
					System.out.println();
					for (int k = 0; k < arr.length; k++) {
						for (int j = 0; j < arr[k].length; j++) {
							System.out.print(arr[k][j]+" ");
						}
						System.out.println();
					}
				}				
			}	
		}
		
	}
	private static boolean checkTwo(int idx, Point_2580 point) {
		Point_2580[] squreCenter = {
				new Point_2580(1, 1), new Point_2580(1, 4), new Point_2580(1, 7),
				new Point_2580(4, 1), new Point_2580(4, 4), new Point_2580(4, 7),
				new Point_2580(7, 1), new Point_2580(7, 4), new Point_2580(7, 7)	
		};
		
		int x = point.getX();
		int y = point.getY();
		arr[y][x] = idx;
		for (int i = 0; i < squreCenter.length; i++) {
			Point_2580 center = squreCenter[i];
			int centerX = center.getX();
			int centerY = center.getY();
			
			if(Math.abs(x - centerX) <= 1 && Math.abs(y - centerY) <= 1) {
				boolean[] visited = new boolean[10];
				int[] dx = {-1, 0, 1, -1, 0, 1, -1, 0, 1};
				int[] dy = {-1, -1, -1, 0, 0, 0, 1, 1, 1};
				for (int j = 0; j < 9; j++) {
					int nextX = centerX + dx[j];
					int nextY = centerY + dy[j];
					int val = arr[nextY][nextX];
					if(val == 0)
						continue;
					if(visited[val] != true) {
						visited[val] = true;
					}
					else if(visited[val] == true) {
						arr[y][x] = 0;
						return false;
					}
				}
				break;
			}
		}
		return true;
	}
	private static boolean checkOne(int i, Point_2580 point, boolean type) {
		arr[point.getY()][point.getX()] = i;
		int[] copyArr = new int[SDQ_Size];
		if(type)
			copy(copyArr, point.getY(), type);
		else
			copy(copyArr, point.getX(), type);
		
		Arrays.sort(copyArr);
		
		for (int j = 0; j < SDQ_Size; j++) {
			if(copyArr[j] != 0) {
				if(j+1 < SDQ_Size && copyArr[j] == copyArr[j + 1]) {
					arr[point.getY()][point.getX()] = 0;
					return false;
				}
			}
		}
		return true;
	}
	
	private static void copy(int[] copyArr, int pivot, boolean type) {
		for (int i = 0; i < SDQ_Size; i++) {
			if(type)//가로축
				copyArr[i] = arr[pivot][i];
			else//세로축
				copyArr[i] = arr[i][pivot];
		}
	}
	
	
}

class Point_2580 {
	int y;
	int x;
	
	public Point_2580(int y, int x) {
		super();
		this.y = y;
		this.x = x;
	}
	
	public int getY() {
		return y;
	}
	public void setY(int y) {
		this.y = y;
	}
	public int getX() {
		return x;
	}
	public void setX(int x) {
		this.x = x;
	}
}
